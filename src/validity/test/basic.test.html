<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>validity: basic</title>
    <script type="module" src="../../../dist/validity.js"></script>
    <style>
        input, select, textarea { display: block; margin: 0.3rem 0 0; }
        :invalid { border: 2px solid #c00; outline-color: #c00; }
        .pwc-validity-message { color: #c00; font-size: 0.85rem; display: block; }
    </style>
</head>

<body>

<h1>validity: basic</h1>

<h2>Initial validity</h2>

<pwc-validity id="v-initial">
    <input id="name" data-validity="Name is required">
    <select id="role" data-validity="Pick a role">
        <option value="">--</option>
        <option value="admin">Admin</option>
    </select>
    <textarea id="bio" data-validity="Bio too short"></textarea>
    <input id="clean" placeholder="no error">
</pwc-validity>

<hr>

<h2>clear-on</h2>

<pwc-validity id="v-clear-on" clear-on="input">
    <input id="clear-on-input" data-validity="Fix this">
</pwc-validity>

<hr>

<h2>clear-after</h2>

<pwc-validity id="v-clear-after" clear-after="500">
    <input id="clear-after-input" data-validity="Goes away soon">
</pwc-validity>

<hr>

<h2>clear-on + clear-after (event wins)</h2>

<pwc-validity id="v-both" clear-on="input" clear-after="5000">
    <input id="both-input" data-validity="Either way">
</pwc-validity>

<hr>

<h2>data-validity-clear="none"</h2>

<pwc-validity id="v-no-clear" clear-on="input" clear-after="200">
    <input id="no-clear-input" data-validity="Stays forever" data-validity-clear="none">
</pwc-validity>

<hr>

<h2>Dynamically added element</h2>

<pwc-validity id="v-dynamic">
</pwc-validity>

<script type="module">
  import { run } from "../../../static/testing/harness.js";
  import { setValue } from "../../../static/testing/helpers.js";

  const msgOf = (el) => el.nextElementSibling?.matches(".pwc-validity-message") ? el.nextElementSibling : null;

  run(async ({ assert, equal, waitFor, log }) => {

    // --- Initial validity ---

    await log("initial: custom validity and message spans are set on connect");
    const name = document.getElementById("name");
    const role = document.getElementById("role");
    const bio = document.getElementById("bio");
    const clean = document.getElementById("clean");

    await waitFor(() => name.validationMessage, { label: "name has validation message" });
    equal(name.validationMessage, "Name is required", "name message");
    equal(msgOf(name)?.textContent, "Name is required", "name message span");
    equal(role.validationMessage, "Pick a role", "role message");
    equal(msgOf(role)?.textContent, "Pick a role", "role message span");
    equal(bio.validationMessage, "Bio too short", "bio message");
    equal(msgOf(bio)?.textContent, "Bio too short", "bio message span");
    equal(clean.validationMessage, "", "clean input has no error");
    equal(msgOf(clean), null, "clean input has no message span");

    // --- clear-on ---

    await log("clear-on: error and message span clear on input event");
    const clearOnInput = document.getElementById("clear-on-input");
    await waitFor(() => clearOnInput.validationMessage, { label: "clear-on has error" });
    assert(msgOf(clearOnInput), "message span present before clear");

    clearOnInput.dispatchEvent(new Event("input", { bubbles: true }));
    await waitFor(() => !clearOnInput.validationMessage, { label: "clear-on error cleared" });
    equal(clearOnInput.validationMessage, "", "error cleared after input event");
    equal(msgOf(clearOnInput), null, "message span removed");

    // --- clear-after ---

    await log("clear-after: error and message span clear after timeout");
    const clearAfterInput = document.getElementById("clear-after-input");
    await waitFor(() => clearAfterInput.validationMessage, { label: "clear-after has error" });
    assert(msgOf(clearAfterInput), "message span present before timeout");

    await waitFor(() => !clearAfterInput.validationMessage, { label: "clear-after error cleared", timeoutMs: 2000 });
    equal(clearAfterInput.validationMessage, "", "error cleared after timeout");
    equal(msgOf(clearAfterInput), null, "message span removed");

    // --- clear-on + clear-after (event wins) ---

    await log("both: event clears before timeout");
    const bothInput = document.getElementById("both-input");
    await waitFor(() => bothInput.validationMessage, { label: "both has error" });

    bothInput.dispatchEvent(new Event("input", { bubbles: true }));
    await waitFor(() => !bothInput.validationMessage, { label: "both error cleared" });
    equal(bothInput.validationMessage, "", "error cleared by event");
    equal(msgOf(bothInput), null, "message span removed");

    // --- data-validity-clear="none" ---

    await log("no-clear: error persists despite clear-on and clear-after");
    const noClearInput = document.getElementById("no-clear-input");
    await waitFor(() => noClearInput.validationMessage, { label: "no-clear has error" });
    equal(noClearInput.validationMessage, "Stays forever", "initial error set");

    noClearInput.dispatchEvent(new Event("input", { bubbles: true }));
    // Wait longer than clear-after (200ms) to confirm it doesn't clear
    await new Promise((r) => setTimeout(r, 350));
    equal(noClearInput.validationMessage, "Stays forever", "error still present after event and timeout");
    assert(msgOf(noClearInput), "message span still present");

    // --- Dynamically added element ---

    await log("dynamic: validity and message span applied to dynamically inserted element");
    const vDynamic = document.getElementById("v-dynamic");
    const dynInput = document.createElement("input");
    dynInput.id = "dyn-input";
    dynInput.setAttribute("data-validity", "Dynamic error");
    vDynamic.appendChild(dynInput);

    await waitFor(() => dynInput.validationMessage, { label: "dynamic input has error" });
    equal(dynInput.validationMessage, "Dynamic error", "dynamic error set");
    equal(msgOf(dynInput)?.textContent, "Dynamic error", "dynamic message span");

    await log("done");
  });
</script>
</body>
</html>
