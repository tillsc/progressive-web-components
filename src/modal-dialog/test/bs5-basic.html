<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>modal-dialog-bs5: stack</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body>
  <script type="module" src="../../../dist/modal-dialog-bs5.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script type="module">
    import { run } from "../../../test/static/harness.js";

    run(async ({ assert, equal, waitFor, log, nextTick }) => {
      const BsModal = window.bootstrap?.Modal;
      assert(BsModal, "Bootstrap Modal missing on window.bootstrap.Modal");

      const waitForShownStable = async (el, label) => {
        // Prefer the public event, but don't hang if it already fired.
        let seenEvent = false;
        const onShown = () => { seenEvent = true; };
        el.addEventListener("shown.bs.modal", onShown, { once: true });

        await waitFor(() => {
          const inst = BsModal.getInstance(el);
          const transitioning = inst && inst._isTransitioning === true; // private but stable enough for tests
          const shown = el.classList.contains("show");
          return shown && !transitioning;
        }, { message: `modal not shown/stable: ${label}` });

        // If event didn't fire (already fired before listener), that's fine.
        el.removeEventListener("shown.bs.modal", onShown);
        if (!seenEvent) {
          // ensure we passed at least one microtask after reaching stable state
          await nextTick(`shown stable (no event): ${label}`);
        }
      };

      log("opening parent modal");
      const parent = document.createElement("pwc-modal-dialog-bs5");
      const parentHandle = parent.open({ title: "Parent", size: "lg" });
      parentHandle.bodyEl.innerHTML = `<p id="parent-body">Parent body</p>`;

      await waitForShownStable(parent, "parent initial");

      equal(document.querySelectorAll(".modal.show").length, 1, "expected exactly one shown modal (parent)");

      log("opening child modal (should suspend parent)");
      const child = document.createElement("pwc-modal-dialog-bs5");
      const childHandle = child.open({ title: "Child", size: "sm" });
      childHandle.bodyEl.innerHTML = `<p id="child-body">Child body</p>`;

      await waitForShownStable(child, "child");

      await waitFor(() => !parent.classList.contains("show"), { message: "parent not suspended" });

      equal(document.querySelectorAll(".modal.show").length, 1, "expected exactly one shown modal (child)");
      assert(document.querySelector(".modal.show") === child, "expected child to be the shown modal");

      log("closing child (should restore parent)");
      childHandle.close();

      await waitFor(() => !child.classList.contains("show"), { message: "child still shown after close" });
      await waitFor(() => parent.classList.contains("show"), { message: "parent not restored after child close" });

      // critical: wait until parent is fully shown again before closing it
      await waitForShownStable(parent, "parent restored");

      equal(document.querySelectorAll(".modal.show").length, 1, "expected exactly one shown modal (restored parent)");
      assert(document.querySelector(".modal.show") === parent, "expected parent to be shown again");

      log("closing parent");
      parentHandle.close();

      await waitFor(() => !parent.classList.contains("show"), { message: "parent still shown after close" });

      await waitFor(() => !document.body.contains(child), { message: "child element not removed" });
      await waitFor(() => !document.body.contains(parent), { message: "parent element not removed" });

      log("done");
    });
  </script>
</body>
</html>